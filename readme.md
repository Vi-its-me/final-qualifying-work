# Как работает проект?

Несколько реализаций работы программы разбиты на следующие функции: 
- передатчик
- приемник
- вычисление уровня сигнала точки
- и получение MAC-адреса точки

Чтобы скомпилировать участки кода только для одной из реализаций, нужно объявить макрос с его названием,
указанным в комментариях в строке (4).
![image](https://github.com/Vi-its-me/final-qualifying-work/assets/163395895/15107b8c-ccab-4895-ab64-11fcdc07e666)

	Передатчик и приемник
Для реализации измерения расстояния по времени прохождения сигнала разработаны две реализации,
одна для передатчика, другая для приемника. 
## Блок объявления

В данном блоке объявлены следующие переменные, массивы, функции и классы: 

- interval (кол-во времени, по прошествии которого в дальнейшем программа переключается с приема сигнала
на отправку)
- MAC_N (N - номер платы)
- sendClass (класс, который содержит все пересылаемые между модулями поля)
- поле to_second_point_packets_array[10] (массив с данными, передаваемыми второму модулю)
- поле received_packets_number (хранит количество принятых пакетов для подсчета суммы в дальнейшем)
- поле processing_time[10] (массив, который хранит время, затраченное на обработку каждого из 10
передаваемых между модулями пакетов
- sendClass send_instance (экземпляр\объект класса, который нужен для обмена данными между модулями)
- OnDataSent и OnDataRecv (функции, вызываемые параметром для отправки и приема пересылаемого объекта
класса

## setup()
- строки 49-61

Инициализация модулей

Для модуля передачи установлена задержка включения, чтобы порт Serial
"успел среагировать" не "потерял" отправляемые на него данные

## loop()
	Передатчик
 Для "распараллеливания" и "одновременного" приема и передачи в рамках одного модуля
 используется конструкция в строке (68).  
 ![image](https://github.com/Vi-its-me/final-qualifying-work/assets/163395895/100346c0-f254-4dee-8889-04a255ed6554)
 
 Работает следующим образом: пока не прошло кол-во времени, 
 большее, чем заданный ранее интервал, модуль принимает данные, в противном случае отправляет.
 
 где 
 - millis() (функция для получения времени, прошедшего с момента включения модуля)

Если интервал достигнут, то модуль инициализируется в качестве передатчика и перебирает в цикле for
весь массив to_second_point_packets_array[10] на наличие 0, либо 2. 

В случае нахождения **первого** 0 программа:
- присваивает в этот элемент 1 (строка 86)
- фиксирует начало отсчета с помощью millis() в processing_time[] (строка 87)
- и отправляет на модуль-приемник весь объект send_instance
- выходит из цикла перебора массива(чтобы не терялся смысл множества измерений, а не одного)

В случае нахождения **первой** 2 программа:
- увеличивает переменную, отвечающую за кол-во принятых пакетов received_packets_number
- считает и фиксирует время обработки(приема-передачи), путем вычитания из текущего времени,
время, зафиксированное на этапе отправки
- присваивает в ячейку вместо 2, 3, чтобы зафиксировать факт окончания обработки данных
- если элемент последний, то в строках (104-117) считает кол-во отправленных и обработанных
пакетов.

##
	Приемник
Аналогично с передатчиком имеет конструкцию "распараллеливания" в теле которой
выполняется:
- нахождение 1 и присвоение в эту ячейку 2(аналогично с передатчиком)
- отправка данных на 1 модуль

За пределами временного ограничителя отправки "interval" модуль принимает данные от
передатчика
